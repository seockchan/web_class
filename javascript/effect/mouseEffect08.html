<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>마우스 이펙트07</title>

    <link rel="stylesheet" href="css/NexonLv1Gothic.css">
    <link rel="stylesheet" href="css/agate.min.css">
    <link rel="stylesheet" href="css/custom.css">

    <style>
        body::before {
            background: rgb(54 12 12 / 80%);
        }
        body{
        margin: 0;
        min-height: 100vh;
        }
        main{
        height: 100vh
        }
        header {
        box-sizing: border-box;
        width: 100%;
        height: 100vh;
        margin: 0 auto;
        /* background-image: url("https://picsum.photos/1920/1080"); */
        background-size: cover;
        background-position: center center;
        white-space: nowrap;
        }

        header#poligon-animate {
        --headerpadding: 3rem;
        --headertextsize: 20px;
        --shadow: 0 0 0.2em black;
        font-size: var(--headertextsize);
        padding: var(--headerpadding);
        display: flex;
        align-items: center;
        position: relative;
        overflow: hidden;
        }

        header#poligon-animate.pa-mouseeffect {
        cursor: none;
        user-select: none;
        }

        header#poligon-animate h1 {
        color: white;
        max-width: 500px;
        z-index: 2;
        text-shadow: var(--shadow);
        font-weight: 500;
        }

        header#poligon-animate h1 span#snap-point {
        display: inline-block;
        width: var(--headertextsize);
        height: var(--headertextsize);
        }

        header#poligon-animate #animation-point {
        /* default starting point: .pa-topright */
        --offset: var(--headerpadding);
        position: absolute;
        left: calc(100% - var(--offset));
        top: var(--offset);
        z-index: 1;
        height: var(--headertextsize);
        width: var(--headertextsize);
        background-color: white;
        border-radius: 50%;
        box-shadow: var(--shadow);
        }
        header#poligon-animate.pa-topleft #animation-point {
        left: var(--offset);
        top: var(--offset);
        }
        header#poligon-animate.pa-topright #animation-point {
        left: calc(100% - var(--offset));
        top: var(--offset);
        }
        header#poligon-animate.pa-bottomleft #animation-point {
        left: var(--offset);
        top: calc(100% - var(--offset));
        }
        header#poligon-animate.pa-bottomright #animation-point {
        left: calc(100% - var(--offset));
        top: calc(100% - var(--offset));
        }
        header#poligon-animate svg {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        mix-blend-mode: multiply;
        }
    </style>
</head>
<body class="img01">
    <header id="poligon-animate" class="pa-topright pa-mouseeffect">
        <h1>Do not try to be original, just try to be good.<br><br>
            독특한 사람이 되려 하지 말아라. 좋은 사람이 되도록 해라.</h1>
      </header>
    <!-- main -->
    <main>
        <section id="mouseType01">
            <div class="cursor"></div>

           

        </section>
    </main>

    <!-- info -->
    <div class="info">
        <div class="title">
        <h1><a href="mouseEffect.html">Javascript Mouse Effect08</a></h1>
        <p>마우스 이펙트 - 이미지 오버효과</p>
        </div>
    
        <div class="number">
        <ul>
            <li><a href="mouseEffect01.html">1</a></li>
            <li><a href="mouseEffect02.html">2</a></li>
            <li><a href="mouseEffect03.html">3</a></li>
            <li><a href="mouseEffect04.html">4</a></li>
            <li><a href="mouseEffect05.html">5</a></li>
            <li><a href="mouseEffect06.html">6</a></li>
            <li><a href="mouseEffect07.html">7</a></li>
            <li class="active"><a href="mouseEffect08.html">8</a></li>
        </ul>
        </div>

        <div class="source">
        <button class="source-btn">소스보기</button>
        <div id="modal">
            <div class="modal-wrap">
                <div class="modal-cont">
                    <div class="code-view">
                        <div class="view-header" aria-hidden="true">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div class="view-title">
                            <ul>
                                <li class="active"><a href="#">HTML</a></li>
                                <li><a href="#">CSS</a></li>
                                <li><a href="#">Javascript</a></li>
                            </ul>
                        </div>
                        <div class="view-cont">
                            <div>
<pre><code class="language-javascript">
</code></pre>
                            </div>
                            <div>
                               
                                    <div>
<pre><code class="language-javascript">
</code></pre>
                                    </div>
                            </div>
                            <div>
                              
                                    <div>
<pre><code class="language-javascript">
</code></pre>
                                    </div>
                            </div>
                            <div>jQuery</div>
                        </div>
                    </div>
                </div>
                <button class="modal-close">닫기</button>
            </div>
        </div>
        </div>
    </div>

    <script src="js/highlight.min.js"></script>
    <script src="js/custom.js"></script>
    <script src="js/gsap.min.js"></script>
    <script>
        highlight();
        modal();
        tabMenu();

        const pa_headerEl = document.querySelector("header#poligon-animate") || false;

if (pa_headerEl) {
  //add svg to header
  const pa_svgEl = pa_createSvg();
  pa_headerEl.append(pa_svgEl);

  //add snap point to h1
  const pa_headerH1El = pa_headerEl.querySelector("h1");
  const pa_snapPointEl = pa_createSnapPoint();
  pa_headerH1El.append(pa_snapPointEl);

  //add animation point to header
  const pa_animationPointEl = pa_createAnimationPoint();
  pa_headerEl.append(pa_animationPointEl);

  //poligon-shapes
  const pa_shapes = [
    {
      points: [
        [0, 0],
        [50, 0],
      ],
      color: pa_createRandomColor(),
    },
    {
      points: [
        [50, 0],
        [100, 0],
      ],
      color: pa_createRandomColor(),
    },
    {
      points: [
        [100, 0],
        [100, 50],
      ],
      color: pa_createRandomColor(),
    },
    {
      points: [
        [100, 50],
        [100, 100],
      ],
      color: pa_createRandomColor(),
    },
    {
      points: [
        [100, 100],
        [50, 100],
      ],
      color: pa_createRandomColor(),
    },
    {
      points: [
        [50, 100],
        [0, 100],
      ],
      color: pa_createRandomColor(),
    },
    {
      points: [
        [0, 100],
        [0, 50],
      ],
      color: pa_createRandomColor(),
    },
    {
      points: [
        [0, 50],
        [0, 0],
      ],
      color: pa_createRandomColor(),
    },
  ];

  // add poligons to svg
  const pa_poligonShapes = [];
  pa_shapes.forEach((shape) => {
    pa_poligonEl = pa_createPoligon(shape);
    pa_svgEl.appendChild(pa_poligonEl);
    pa_poligonShapes.push(pa_poligonEl);
  });

  // event handlers
  window.onresize = pa_updatePoligonShapes;
  if (pa_headerEl.classList.contains("pa-mouseeffect")) {
    pa_headerEl.addEventListener("mouseout", pa_animateToSnapPoint);
    pa_headerEl.addEventListener("mousemove", pa_followMouse);
    pa_headerEl.addEventListener("mouseover", pa_followMouse);
  }

  // start
  let pa_snapAnimate = true;
  pa_animateToSnapPoint();
  function pa_animateToSnapPoint() {
    pa_snapAnimate = true;
    let steps = 100;
    let point = pa_getPointRelativePosition();
    let pointX = point[0];
    let pointY = point[1];
    let target = pa_getSnapPointRelativePosition();
    let targetX = target[0];
    let targetY = target[1];
    let distX = pointX - targetX;
    let distY = pointY - targetY;
    let stepX = distX / steps;
    let stepY = distY / steps;
    let count = 0;
    let loopId = setInterval(() => {
      animate();
    }, 1);

    function animate() {
      count++;
      if (pa_snapAnimate && count < steps) {
        pa_animationPointEl.style.left =
          (pointX - stepX * count).toFixed(2) + "%";
        pa_animationPointEl.style.top =
          (pointY - stepY * count).toFixed(2) + "%";
        pa_updatePoligonShapes();
      } else {
        clearInterval(loopId);
      }
    }

    console.log([
      pa_animationPointEl.style.left,
      pa_animationPointEl.style.top,
    ]);
  }

  function pa_createSvg() {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.classList.add("poligon-animate-svg");
    svg.setAttribute("viewBox", "0 0 100 100");
    svg.setAttribute("preserveAspectRatio", "none");
    return svg;
  }

  function pa_createSnapPoint() {
    const point = document.createElement("span");
    point.id = "snap-point";
    return point;
  }

  function pa_createAnimationPoint() {
    const point = document.createElement("div");
    point.id = "animation-point";
    return point;
  }

  function pa_createPoligon(shape) {
    let poligon = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "polygon"
    );
    let points = shape.points.join(" ");
    points += " " + pa_getPointRelativePosition();
    poligon.setAttribute("points", points);
    poligon.setAttribute("style", `fill: ${shape.color}`);
    return poligon;
  }

  function pa_updatePoligonShapes() {
    pa_poligonShapes.forEach((poligonShape, index) => {
      let points = pa_shapes[index].points.join(" ");
      points += " " + pa_getPointRelativePosition();
      poligonShape.setAttribute("points", points);
    });
  }

  function pa_createRandomColor() {
    return "#" + Math.floor(Math.random() * 16777215).toString(16);
  }

  function pa_getMouseRelativePosition(e) {
    let headerRect = pa_headerEl.getBoundingClientRect();
    let pointRect = pa_animationPointEl.getBoundingClientRect();

    let pointCenterX = e.clientX - headerRect.left - pointRect.width / 2;
    let pointCenterY = e.clientY - headerRect.top - pointRect.height / 2;

    let pointXRelative = ((pointCenterX / headerRect.width) * 100).toFixed(2);
    let pointYRelative = ((pointCenterY / headerRect.height) * 100).toFixed(2);
    return [pointXRelative, pointYRelative];
  }

  function pa_getPointRelativePosition() {
    let headerRect = pa_headerEl.getBoundingClientRect();
    let pointRect = pa_animationPointEl.getBoundingClientRect();

    let pointCenterX = pointRect.left - headerRect.left + pointRect.width / 2;
    let pointCenterY = pointRect.top - headerRect.top + pointRect.height / 2;

    let pointXRelative = ((pointCenterX / headerRect.width) * 100).toFixed(2);
    let pointYRelative = ((pointCenterY / headerRect.height) * 100).toFixed(2);
    return [pointXRelative, pointYRelative];
  }

  function pa_getSnapPointRelativePosition() {
    let headerRect = pa_headerEl.getBoundingClientRect();
    let pointRect = pa_snapPointEl.getBoundingClientRect();

    let pointCenterX = pointRect.left - headerRect.left;
    let pointCenterY = pointRect.top - headerRect.top;

    let pointXRelative = ((pointCenterX / headerRect.width) * 100).toFixed(2);
    let pointYRelative = ((pointCenterY / headerRect.height) * 100).toFixed(2);
    return [pointXRelative, pointYRelative];
  }

  function pa_followMouse(e) {
    pa_snapAnimate = false;
    let relativePosition = pa_getMouseRelativePosition(e);
    pa_animationPointEl.style.left = relativePosition[0] + "%";
    pa_animationPointEl.style.top = relativePosition[1] + "%";
    pa_updatePoligonShapes();
  }
}
    </script>
</body>
</html>